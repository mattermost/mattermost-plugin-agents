// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package conversations

import (
	"encoding/json"
	"fmt"
	"io"
	"slices"
	"strings"

	"errors"

	"github.com/mattermost/mattermost-plugin-ai/agents/format"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost-plugin-ai/streaming"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/pluginapi"
)

const defaultMaxFileSize = int64(1024 * 1024 * 5) // 5MB
const UnsafeLinksPostProp = "unsafe_links"

func (c *Conversations) modifyPostForBot(botid string, requesterUserID string, post *model.Post, respondingToPostID string) {
	post.UserId = botid
	post.Type = "custom_llmbot" // This must be the only place we add this type for security.
	post.AddProp(LLMRequesterUserID, requesterUserID)
	// This tags that the post has unsafe links since they could have been generated by a prompt injection.
	// This will prevent the server from making OpenGraph requests and markdown images being rendered.
	post.AddProp(UnsafeLinksPostProp, "true")

	// Add the ID of the post we're responding to
	if respondingToPostID != "" {
		post.AddProp(RespondingToProp, respondingToPostID)
	}
}

func (c *Conversations) botCreateNonResponsePost(botid string, requesterUserID string, post *model.Post) error {
	c.modifyPostForBot(botid, requesterUserID, post, "")
	post.AddProp(NoRegen, true)

	if err := c.pluginAPI.Post.CreatePost(post); err != nil {
		return err
	}

	return nil
}

func isImageMimeType(mimeType string) bool {
	return strings.HasPrefix(mimeType, "image/")
}

func (c *Conversations) PostToAIPost(bot *bots.Bot, post *model.Post) llm.Post {
	var filesForUpstream []llm.File
	message := format.PostBody(post)
	var extractedFileContents []string

	maxFileSize := defaultMaxFileSize
	if bot.GetConfig().MaxFileSize > 0 {
		maxFileSize = bot.GetConfig().MaxFileSize
	}

	for _, fileID := range post.FileIds {
		fileInfo, err := c.pluginAPI.File.GetInfo(fileID)
		if err != nil {
			c.pluginAPI.Log.Error("Error getting file info", "error", err)
			continue
		}

		// Check for files that have been interpreted already by the server or are text files.
		content := ""
		if trimmedContent := strings.TrimSpace(fileInfo.Content); trimmedContent != "" {
			content = trimmedContent
		} else if strings.HasPrefix(fileInfo.MimeType, "text/") {
			file, err := c.pluginAPI.File.Get(fileID)
			if err != nil {
				c.pluginAPI.Log.Error("Error getting file", "error", err)
				continue
			}
			contentBytes, err := io.ReadAll(io.LimitReader(file, maxFileSize))
			if err != nil {
				c.pluginAPI.Log.Error("Error reading file content", "error", err)
				continue
			}
			content = string(contentBytes)
			if int64(len(contentBytes)) == maxFileSize {
				content += "\n... (content truncated due to size limit)"
			}
		}

		if content != "" {
			fileContent := fmt.Sprintf("File Name: %s\nContent: %s", fileInfo.Name, content)
			extractedFileContents = append(extractedFileContents, fileContent)
		}

		if bot.GetConfig().EnableVision && isImageMimeType(fileInfo.MimeType) {
			file, err := c.pluginAPI.File.Get(fileID)
			if err != nil {
				c.pluginAPI.Log.Error("Error getting file", "error", err)
				continue
			}
			filesForUpstream = append(filesForUpstream, llm.File{
				Reader:   file,
				MimeType: fileInfo.MimeType,
				Size:     fileInfo.Size,
			})
		}
	}

	// Add structured file contents to the message
	if len(extractedFileContents) > 0 {
		message += "\nAttached File Contents:\n" + strings.Join(extractedFileContents, "\n\n")
	}

	role := llm.PostRoleUser
	if c.bots.IsAnyBot(post.UserId) {
		role = llm.PostRoleBot
	}

	// Check for tools
	pendingToolsProp := post.GetProp(streaming.ToolCallProp)
	tools := []llm.ToolCall{}
	pendingTools, ok := pendingToolsProp.(string)
	if ok {
		var toolCalls []llm.ToolCall
		if err := json.Unmarshal([]byte(pendingTools), &toolCalls); err != nil {
			c.pluginAPI.Log.Error("Error unmarshalling tool calls", "error", err)
		} else {
			tools = toolCalls
		}
	}

	return llm.Post{
		Role:    role,
		Message: message,
		Files:   filesForUpstream,
		ToolUse: tools,
	}
}

func (c *Conversations) ThreadToLLMPosts(bot *bots.Bot, posts []*model.Post) []llm.Post {
	result := make([]llm.Post, 0, len(posts))

	for _, post := range posts {
		result = append(result, c.PostToAIPost(bot, post))
	}

	return result
}

func (c *Conversations) checkUsageRestrictionsForUser(bot *bots.Bot, requestingUserID string) error {
	switch bot.GetConfig().UserAccessLevel {
	case llm.UserAccessLevelAll:
		return nil
	case llm.UserAccessLevelAllow:
		// Check direct user allowlist
		if slices.Contains(bot.GetConfig().UserIDs, requestingUserID) {
			return nil
		}
		// Check team membership
		for _, teamID := range bot.GetConfig().TeamIDs {
			isMember, err := c.isMemberOfTeam(teamID, requestingUserID)
			if err != nil {
				return err
			}
			if isMember {
				return nil
			}
		}
		return fmt.Errorf("user not allowed")
	case llm.UserAccessLevelBlock:
		// Check direct user blocklist
		if slices.Contains(bot.GetConfig().UserIDs, requestingUserID) {
			return fmt.Errorf("user blocked")
		}
		// Check team membership
		for _, teamID := range bot.GetConfig().TeamIDs {
			isMember, err := c.isMemberOfTeam(teamID, requestingUserID)
			if err != nil {
				return err
			}
			if isMember {
				return fmt.Errorf("user's team blocked")
			}
		}
		return nil
	case llm.UserAccessLevelNone:
		return fmt.Errorf("user usage block for bot")
	}

	return fmt.Errorf("unknown user assistance level")
}

func (c *Conversations) isMemberOfTeam(teamID string, userID string) (bool, error) {
	member, err := c.pluginAPI.Team.GetMember(teamID, userID)
	if errors.Is(err, pluginapi.ErrNotFound) {
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return member != nil && member.DeleteAt == 0, nil
}
