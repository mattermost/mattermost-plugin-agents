// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package main

import (
	"context"
	"net/http"
	"os"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/mattermost/mattermost-plugin-ai/agents"
	"github.com/mattermost/mattermost-plugin-ai/api"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/config"
	"github.com/mattermost/mattermost-plugin-ai/conversations"
	"github.com/mattermost/mattermost-plugin-ai/database"
	"github.com/mattermost/mattermost-plugin-ai/enterprise"
	"github.com/mattermost/mattermost-plugin-ai/i18n"
	"github.com/mattermost/mattermost-plugin-ai/indexer"
	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost-plugin-ai/llmcontext"
	"github.com/mattermost/mattermost-plugin-ai/mcp"
	"github.com/mattermost/mattermost-plugin-ai/meetings"
	"github.com/mattermost/mattermost-plugin-ai/metrics"
	"github.com/mattermost/mattermost-plugin-ai/mmapi"
	"github.com/mattermost/mattermost-plugin-ai/mmtools"
	"github.com/mattermost/mattermost-plugin-ai/search"
	"github.com/mattermost/mattermost-plugin-ai/streaming"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/mattermost/mattermost/server/public/shared/httpservice"
)

func main() {
	plugin.ClientMain(&Plugin{})
}

type Plugin struct {
	plugin.MattermostPlugin

	configuration config.ConfigContainer

	pluginAPI             *pluginapi.Client
	llmUpstreamHTTPClient *http.Client
	db                    *sqlx.DB

	agentsService    *agents.AgentsService
	meetingsService  *meetings.Service
	indexerService   *indexer.Indexer
	searchService    *search.Search
	apiService       *api.API
	bots             *bots.MMBots
	toolProvider     *mmtools.MMToolProvider
	mcpClientManager *mcp.ClientManager
}

func (p *Plugin) OnActivate() error {
	p.pluginAPI = pluginapi.NewClient(p.API, p.Driver)

	p.llmUpstreamHTTPClient = httpservice.MakeHTTPServicePlugin(p.API).MakeClient(true)
	p.llmUpstreamHTTPClient.Timeout = time.Minute * 10 // LLM requests can be slow

	untrustedHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(false)

	metricsService := metrics.NewMetrics(metrics.InstanceInfo{
		InstallationID: os.Getenv("MM_CLOUD_INSTALLATION_ID"),
		PluginVersion:  manifest.Version, // Manifest imported from manifest.go which is generated by the build process
	})

	updated, newCfg, err := MigrateServicesToBots(p.API, p.pluginAPI, *p.configuration.Config())
	if err != nil {
		p.pluginAPI.Log.Error("failed to migrate services to bots", "error", err)
		// Don't fail on migration errors
	}
	if updated && err == nil {
		p.configuration.Update(&newCfg)
	}

	licenseChecker := enterprise.NewLicenseChecker(p.pluginAPI)

	p.bots = bots.New(p.API, p.pluginAPI, licenseChecker, &p.configuration, p.llmUpstreamHTTPClient)
	p.configuration.RegisterUpdateListener(func() {
		if ensureErr := p.bots.EnsureBots(p.configuration.GetBots()); ensureErr != nil {
			p.pluginAPI.Log.Error("failed to ensure bots on configuration update", "error", ensureErr)
			return
		}
	})

	if ensureBotsErr := p.bots.EnsureBots(newCfg.Bots); ensureBotsErr != nil {
		// If we fail to ensure bots, we log the error but do not return
		// as it would leave the plugin in a state where it can't be configured from the system console.
		p.pluginAPI.Log.Error("failed to ensure bots", "error", ensureBotsErr)
	}

	// Set up database
	mmClient := mmapi.NewClient(p.pluginAPI)
	dbClient := mmapi.NewDBClient(p.pluginAPI)
	p.db = dbClient.DB

	// Set up database tables
	if setupTablesErr := database.SetupTables(p.db); setupTablesErr != nil {
		p.pluginAPI.Log.Error("failed to setup database tables", "error", setupTablesErr)
		return setupTablesErr
	}

	// Initialize prompts before creating services
	prompts, promptManagerErr := llm.NewPrompts(llm.PromptsFolder)
	if promptManagerErr != nil {
		p.pluginAPI.Log.Error("failed to initialize prompts", "error", promptManagerErr)
		return promptManagerErr
	}

	// Create i18n bundle
	i18nBundle := i18n.Init()

	// Initialize search and indexer services independently
	embeddings, err := search.InitSearch(p.db, p.llmUpstreamHTTPClient, p.configuration.EmbeddingSearchConfig(), licenseChecker)
	if err != nil {
		p.pluginAPI.Log.Error("failed to initialize search infrastructure", "error", err)
		// Continue without search functionality
	}

	// Initialize indexer service (always created, handles nil search gracefully)
	p.indexerService = indexer.New(embeddings, mmClient, p.bots, p.db)

	// Create temporary streaming service
	tempStreamingService := streaming.NewMMPostStreamService(mmClient, i18nBundle, nil)

	p.searchService = search.New(
		embeddings,
		mmClient,
		prompts,
		tempStreamingService,
		p.llmUpstreamHTTPClient,
		p.db,
		licenseChecker,
	)

	p.toolProvider = mmtools.NewMMToolProvider(
		mmClient,
		p.searchService,
		untrustedHTTPClient,
	)

	mcpClient, err := mcp.NewClientManager(p.configuration.MCP(), p.pluginAPI.Log)
	if err != nil {
		p.pluginAPI.Log.Error("Failed to initialize MCP client manager, MCP tools will be disabled", "error", err)
	} else {
		p.mcpClientManager = mcpClient
	}
	p.configuration.RegisterUpdateListener(func() {
		// Close existing MCP client manager
		if p.mcpClientManager != nil {
			if closeErr := p.mcpClientManager.Close(); closeErr != nil {
				p.pluginAPI.Log.Error("Failed to close MCP client manager during configuration change", "error", closeErr)
			}
		}

		// Reinitialize MCP client manager with new configuration
		mcpClient, mcpErr := mcp.NewClientManager(p.configuration.MCP(), p.pluginAPI.Log)
		if mcpErr != nil {
			p.pluginAPI.Log.Error("Failed to reinitialize MCP client manager, MCP tools will be disabled", "error", mcpErr)
			p.mcpClientManager = nil
		} else {
			p.mcpClientManager = mcpClient
			p.pluginAPI.Log.Debug("MCP client manager reinitialized successfully")
		}
	})

	contextBuilder := llmcontext.NewLLMContextBuilder(
		p.pluginAPI,
		p.toolProvider,
		p.mcpClientManager,
		&p.configuration,
	)

	// Initialize the agents service first (without conversations service)
	agentsService, err := agents.NewAgentsService(p.API, p.pluginAPI, p.llmUpstreamHTTPClient, untrustedHTTPClient, metricsService, p.bots, contextBuilder, p.db, dbClient.Builder(), nil)
	if err != nil {
		return err
	}
	p.agentsService = agentsService

	// Now initialize conversations service with bots service checkUsageRestrictions method
	conversationsService := conversations.New(
		prompts,
		mmapi.NewClient(p.pluginAPI),
		p.pluginAPI,
		tempStreamingService,
		contextBuilder,
		p.bots,
		p.db,
		dbClient.Builder(),
		enterprise.NewLicenseChecker(p.pluginAPI),
		i18nBundle,
		p.bots.CheckUsageRestrictions,
	)

	// Now create the real streaming service with the correct postModifier
	streamingService := streaming.NewMMPostStreamService(mmClient, i18nBundle, conversationsService.ModifyPostForBot)

	// Update the conversations service with the real streaming service
	conversationsService.SetStreamingService(streamingService)

	// Update the agents service with the conversation service
	agentsService.SetConversationService(conversationsService)

	// Initialize the meetings service
	p.meetingsService = meetings.NewService(
		p.pluginAPI,
		streamingService,
		prompts,
		p.bots,
		i18nBundle,
		metricsService,
		p.db,
		dbClient.Builder(),
		contextBuilder,
		conversationsService.BotCreateNonResponsePost,
		conversationsService.ModifyPostForBot,
		conversationsService.SaveTitle,
		conversationsService.SaveTitleAsync,
		p.bots.GetBotByID,
		agentsService.ExecBuilder,
	)

	// Initialize the API service with all services
	p.apiService = api.New(
		p.agentsService,
		p.bots,
		conversationsService,
		p.meetingsService,
		p.indexerService,
		p.searchService,
		p.pluginAPI,
		metricsService,
		contextBuilder,
		&p.configuration,
		prompts,
		mmClient,
	)

	return nil
}

func (p *Plugin) OnDeactivate() error {
	// Clean up MCP client manager if it exists
	if p.mcpClientManager != nil {
		if err := p.mcpClientManager.Close(); err != nil {
			p.pluginAPI.Log.Error("Failed to close MCP client manager during deactivation", "error", err)
		}
	}

	// No specific cleanup needed for agents service
	return nil
}

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	// Index the new message in the vector database
	if p.indexerService != nil {
		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(post.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			if err := p.indexerService.IndexPost(context.Background(), post, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index post in vector database", "error", err)
			}
		}
	}
}

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
	// Handle indexing of updated posts
	if p.indexerService != nil {
		// Delete the old post from index
		if err := p.indexerService.DeletePost(context.Background(), oldPost.Id); err != nil {
			p.pluginAPI.Log.Error("Failed to delete post from vector database", "error", err)
		}

		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(newPost.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			// Index the updated post
			if err := p.indexerService.IndexPost(context.Background(), newPost, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index updated post in vector database", "error", err)
			}
		}
	}
}

func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeHTTP(c, w, r)
}

func (p *Plugin) ServeMetrics(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeMetrics(c, w, r)
}
