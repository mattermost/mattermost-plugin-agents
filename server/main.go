// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package main

import (
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/mattermost/mattermost-plugin-ai/agents"
	"github.com/mattermost/mattermost-plugin-ai/api"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/enterprise"
	"github.com/mattermost/mattermost-plugin-ai/metrics"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/mattermost/mattermost/server/public/shared/httpservice"
)

func main() {
	plugin.ClientMain(&Plugin{})
}

type Plugin struct {
	plugin.MattermostPlugin

	// configurationLock synchronizes access to the configuration.
	configurationLock sync.RWMutex

	// configuration is the active plugin configuration. Consult getConfiguration and
	// setConfiguration for usage.
	configuration *configuration

	pluginAPI             *pluginapi.Client
	llmUpstreamHTTPClient *http.Client

	agentsService *agents.AgentsService
	apiService    *api.API
	bots          *bots.MMBots
}

func (p *Plugin) OnActivate() error {
	p.pluginAPI = pluginapi.NewClient(p.API, p.Driver)

	p.llmUpstreamHTTPClient = httpservice.MakeHTTPServicePlugin(p.API).MakeClient(true)
	p.llmUpstreamHTTPClient.Timeout = time.Minute * 10 // LLM requests can be slow

	untrustedHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(false)

	metricsService := metrics.NewMetrics(metrics.InstanceInfo{
		InstallationID: os.Getenv("MM_CLOUD_INSTALLATION_ID"),
		PluginVersion:  manifest.Version, // Manifest imported from manifest.go which is generated by the build process
	})

	newCfg, err := MigrateServicesToBots(p.API, p.pluginAPI, p.configuration.Config)
	if err != nil {
		p.pluginAPI.Log.Error("failed to migrate services to bots", "error", err)
		// Don't fail on migration errors
	}
	p.setConfiguration(&configuration{newCfg})

	licenseChecker := enterprise.NewLicenseChecker(p.pluginAPI)

	p.bots = bots.New(p.API, p.pluginAPI, licenseChecker)

	if err := p.bots.EnsureBots(newCfg.Bots); err != nil {
		// If we fail to ensure bots, we log the error but do not return
		// as it would leave the plugin in a state where it can't be configured from the system console.
		p.pluginAPI.Log.Error("failed to ensure bots", "error", err)
	}

	// Initialize the agents service
	agentsService, err := agents.NewAgentsService(p.API, p.pluginAPI, p.llmUpstreamHTTPClient, untrustedHTTPClient, metricsService, &p.configuration.Config, p.bots)
	if err != nil {
		return err
	}

	p.agentsService = agentsService

	// Initialize the API service
	p.apiService = api.New(agentsService, p.pluginAPI, metricsService)

	return nil
}

func (p *Plugin) OnDeactivate() error {
	if p.agentsService != nil {
		if err := p.agentsService.OnDeactivate(); err != nil {
			p.pluginAPI.Log.Error("Error during AgentsService deactivation", "error", err)
			return err
		}
	}
	return nil
}

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	p.agentsService.MessageHasBeenPosted(c, post)
}

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
	p.agentsService.MessageHasBeenUpdated(c, newPost, oldPost)
}

func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeHTTP(c, w, r)
}

func (p *Plugin) ServeMetrics(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeMetrics(c, w, r)
}
