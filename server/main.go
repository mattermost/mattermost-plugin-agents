// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package main

import (
	"context"
	"net/http"
	"os"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/mattermost/mattermost-plugin-ai/agents"
	"github.com/mattermost/mattermost-plugin-ai/api"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/config"
	"github.com/mattermost/mattermost-plugin-ai/conversations"
	"github.com/mattermost/mattermost-plugin-ai/database"
	"github.com/mattermost/mattermost-plugin-ai/enterprise"
	"github.com/mattermost/mattermost-plugin-ai/i18n"
	"github.com/mattermost/mattermost-plugin-ai/indexer"
	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost-plugin-ai/mcp"
	"github.com/mattermost/mattermost-plugin-ai/meetings"
	"github.com/mattermost/mattermost-plugin-ai/metrics"
	"github.com/mattermost/mattermost-plugin-ai/mmapi"
	"github.com/mattermost/mattermost-plugin-ai/mmtools"
	"github.com/mattermost/mattermost-plugin-ai/search"
	"github.com/mattermost/mattermost-plugin-ai/streaming"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/mattermost/mattermost/server/public/shared/httpservice"
)

func main() {
	plugin.ClientMain(&Plugin{})
}

type Plugin struct {
	plugin.MattermostPlugin

	configuration config.ConfigContainer

	pluginAPI             *pluginapi.Client
	llmUpstreamHTTPClient *http.Client
	db                    *sqlx.DB

	agentsService    *agents.AgentsService
	meetingsService  *meetings.Service
	indexerService   *indexer.Indexer
	searchService    *search.Search
	apiService       *api.API
	bots             *bots.MMBots
	toolProvider     *mmtools.MMToolProvider
	mcpClientManager *mcp.ClientManager
}

func (p *Plugin) OnActivate() error {
	p.pluginAPI = pluginapi.NewClient(p.API, p.Driver)

	p.llmUpstreamHTTPClient = httpservice.MakeHTTPServicePlugin(p.API).MakeClient(true)
	p.llmUpstreamHTTPClient.Timeout = time.Minute * 10 // LLM requests can be slow

	untrustedHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(false)

	metricsService := metrics.NewMetrics(metrics.InstanceInfo{
		InstallationID: os.Getenv("MM_CLOUD_INSTALLATION_ID"),
		PluginVersion:  manifest.Version, // Manifest imported from manifest.go which is generated by the build process
	})

	prompts, promptManagerErr := llm.NewPrompts(llm.PromptsFolder)
	if promptManagerErr != nil {
		p.pluginAPI.Log.Error("failed to initialize prompts", "error", promptManagerErr)
		return nil
	}

	updated, newCfg, err := MigrateServicesToBots(p.API, p.pluginAPI, *p.configuration.Config())
	if err != nil {
		p.pluginAPI.Log.Error("failed to migrate services to bots", "error", err)
		// Don't fail on migration errors
	}
	if updated && err == nil {
		p.configuration.Update(&newCfg)
	}

	licenseChecker := enterprise.NewLicenseChecker(p.pluginAPI)

	p.bots = bots.New(p.API, p.pluginAPI, licenseChecker, &p.configuration, p.llmUpstreamHTTPClient)
	p.configuration.RegisterUpdateListener(func() {
		if err := p.bots.EnsureBots(p.configuration.GetBots()); err != nil {
			p.pluginAPI.Log.Error("failed to ensure bots on configuration update", "error", err)
			return
		}
	})

	if ensureBotsErr := p.bots.EnsureBots(newCfg.Bots); ensureBotsErr != nil {
		// If we fail to ensure bots, we log the error but do not return
		// as it would leave the plugin in a state where it can't be configured from the system console.
		p.pluginAPI.Log.Error("failed to ensure bots", "error", ensureBotsErr)
	}

	// Set up database
	mmClient := mmapi.NewClient(p.pluginAPI)
	dbClient := mmapi.NewDBClient(p.pluginAPI)
	p.db = dbClient.DB

	// Set up database tables
	if setupTablesErr := database.SetupTables(p.db); setupTablesErr != nil {
		p.pluginAPI.Log.Error("failed to setup database tables", "error", setupTablesErr)
		return setupTablesErr
	}

	// Initialize search and indexer services independently
	embeddings, err := search.InitSearch(p.db, p.llmUpstreamHTTPClient, p.configuration.EmbeddingSearchConfig(), licenseChecker)
	if err != nil {
		p.pluginAPI.Log.Error("failed to initialize search infrastructure", "error", err)
		// Continue without search functionality
	}

	// Initialize indexer service (always created, handles nil search gracefully)
	p.indexerService = indexer.New(embeddings, mmClient, p.bots, p.db)

	// Create i18n bundle
	i18nBundle := i18n.Init()
	streamingService := streaming.NewMMPostStreamService(mmClient, i18nBundle, nil)

	p.searchService = search.New(
		embeddings,
		mmClient,
		prompts,
		streamingService,
		p.llmUpstreamHTTPClient,
		p.db,
		licenseChecker,
	)

	p.toolProvider = mmtools.NewMMToolProvider(
		mmClient,
		p.searchService,
		untrustedHTTPClient,
	)

	mcpClient, err := mcp.NewClientManager(p.configuration.MCP(), p.pluginAPI.Log)
	if err != nil {
		p.pluginAPI.Log.Error("Failed to initialize MCP client manager, MCP tools will be disabled", "error", err)
	} else {
		p.mcpClientManager = mcpClient
	}
	p.configuration.RegisterUpdateListener(func() {
		// Close existing MCP client manager
		if p.mcpClientManager != nil {
			if err := p.mcpClientManager.Close(); err != nil {
				p.pluginAPI.Log.Error("Failed to close MCP client manager during configuration change", "error", err)
			}
		}

		// Reinitialize MCP client manager with new configuration
		mcpClient, err := mcp.NewClientManager(p.configuration.MCP(), p.pluginAPI.Log)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to reinitialize MCP client manager, MCP tools will be disabled", "error", err)
			p.mcpClientManager = nil
		} else {
			p.mcpClientManager = mcpClient
			p.pluginAPI.Log.Debug("MCP client manager reinitialized successfully")
		}
	})

	contextBuilder := agents.NewLLMContextBuilder(
		p.pluginAPI,
		p.toolProvider,
		p.mcpClientManager,
		&p.configuration,
	)

	// Initialize conversations service
	conversationsService := conversations.New(
		func(cfg llm.BotConfig) llm.LanguageModel {
			// We'll set this up properly after agents service is created
			return nil
		},
		nil, // prompts - will be set later
		mmapi.NewClient(p.pluginAPI),
		p.pluginAPI,
		nil, // streaming service - will be set later
		contextBuilder,
		p.bots,
		p.db,
		dbClient.Builder(),
		enterprise.NewLicenseChecker(p.pluginAPI),
		i18n.Init(),
		func(userID string, bot *bots.Bot, channel *model.Channel) error {
			// Temporary implementation - will be replaced after agents service is created
			return nil
		},
	)

	//TODO: add listener for search related reinitalization

	// Initialize the agents service
	agentsService, err := agents.NewAgentsService(p.API, p.pluginAPI, p.llmUpstreamHTTPClient, untrustedHTTPClient, metricsService, p.bots, contextBuilder, p.db, dbClient.Builder(), conversationsService)
	if err != nil {
		return err
	}
	p.agentsService = agentsService

	// Initialize the meetings service
	p.meetingsService = meetings.NewService(
		p.pluginAPI,
		agentsService.GetStreamingService(),
		agentsService.GetPrompts(),
		p.bots,
		agentsService.GetI18n(),
		metricsService,
		p.db,
		dbClient.Builder(),
		contextBuilder,
		agentsService.BotDMNonResponse,
		agentsService.ModifyPostForBot,
		agentsService.SaveTitle,
		agentsService.SaveTitleAsync,
		agentsService.GetBotByID,
		agentsService.ExecBuilder,
	)

	// Initialize the API service with all services
	p.apiService = api.New(p.agentsService, p.bots, conversationsService, p.meetingsService, p.indexerService, p.searchService, p.pluginAPI, metricsService, &p.configuration)

	return nil
}

func (p *Plugin) OnDeactivate() error {
	// Clean up MCP client manager if it exists
	if p.mcpClientManager != nil {
		if err := p.mcpClientManager.Close(); err != nil {
			p.pluginAPI.Log.Error("Failed to close MCP client manager during deactivation", "error", err)
		}
	}

	if p.agentsService != nil {
		if err := p.agentsService.OnDeactivate(); err != nil {
			p.pluginAPI.Log.Error("Error during AgentsService deactivation", "error", err)
			return err
		}
	}
	return nil
}

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	// Index the new message in the vector database
	if p.indexerService != nil {
		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(post.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			if err := p.indexerService.IndexPost(context.Background(), post, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index post in vector database", "error", err)
			}
		}
	}

	// Keep existing AgentsService calls for other functionality
	p.agentsService.MessageHasBeenPosted(c, post)
}

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
	// Handle indexing of updated posts
	if p.indexerService != nil {
		// Delete the old post from index
		if err := p.indexerService.DeletePost(context.Background(), oldPost.Id); err != nil {
			p.pluginAPI.Log.Error("Failed to delete post from vector database", "error", err)
		}

		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(newPost.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			// Index the updated post
			if err := p.indexerService.IndexPost(context.Background(), newPost, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index updated post in vector database", "error", err)
			}
		}
	}
}

func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeHTTP(c, w, r)
}

func (p *Plugin) ServeMetrics(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeMetrics(c, w, r)
}
